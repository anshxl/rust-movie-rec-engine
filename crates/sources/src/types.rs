//! Core types for candidate generation.
//!
//! This module defines the data structures used by Thunder and Phoenix sources
//! to represent movie candidates and user context.

use data_loader::{Genre, MovieId, UserId};
use std::collections::{HashMap, HashSet};

/// Identifies which source generated a candidate
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CandidateSource {
    /// In-network collaborative filtering (Thunder)
    Thunder,
    /// Out-of-network discovery (Phoenix)
    Phoenix,
}

/// Additional metadata about how a candidate was generated
#[derive(Debug, Clone)]
pub struct CandidateMetadata {
    /// How many similar users rated this movie (for Thunder)
    pub similar_users_count: Option<u32>,

    /// Which genres matched user preferences (for Phoenix)
    pub matched_genres: Vec<Genre>,

    /// Was this from popularity-based discovery?
    pub from_popularity: bool,

    /// Was this from temporal/era-based discovery?
    pub from_temporal: bool,
}

impl CandidateMetadata {
    pub fn new() -> Self {
        Self {
            similar_users_count: None,
            matched_genres: Vec::new(),
            from_popularity: false,
            from_temporal: false,
        }
    }
}

impl Default for CandidateMetadata {
    fn default() -> Self {
        Self::new()
    }
}

/// A movie candidate for recommendation
///
/// Each candidate is generated by either Thunder or Phoenix source
/// and includes a base score and metadata about how it was found.
#[derive(Debug, Clone)]
pub struct Candidate {
    /// The movie ID
    pub movie_id: MovieId,

    /// Which source generated this candidate
    pub source: CandidateSource,

    /// Base score from the source (before ML scoring)
    /// - For Thunder: collaborative filtering score
    /// - For Phoenix: genre/popularity/temporal match score
    pub base_score: f32,

    /// Additional metadata about candidate generation
    pub metadata: CandidateMetadata,
}

impl Candidate {
    pub fn new(movie_id: MovieId, source: CandidateSource, base_score: f32) -> Self {
        Self {
            movie_id,
            source,
            base_score,
            metadata: CandidateMetadata::new(),
        }
    }
}

/// User context needed for candidate generation
///
/// This struct aggregates information about a user that's frequently needed
/// during candidate generation, so we don't have to repeatedly query DataIndex.
#[derive(Debug, Clone)]
pub struct UserContext {
    /// The user ID
    pub user_id: UserId,

    /// Movies the user has already rated (for filtering)
    pub watched_movies: HashSet<MovieId>,

    /// Movies the user rated highly (>= 4.0)
    pub highly_rated_movies: Vec<MovieId>,

    /// Genre preferences with scores
    /// Key: Genre, Value: Average rating for that genre
    pub genre_preferences: HashMap<Genre, f32>,

    /// User's preferred movie era (median year of highly-rated movies)
    pub preferred_era: Option<u16>,

    /// Average rating this user gives
    pub avg_rating: f32,
}

impl UserContext {
    /// Create a new empty UserContext for the given user
    pub fn new(user_id: UserId) -> Self {
        Self {
            user_id,
            watched_movies: HashSet::new(),
            highly_rated_movies: Vec::new(),
            genre_preferences: HashMap::new(),
            preferred_era: None,
            avg_rating: 0.0,
        }
    }

    /// Get the user's top N preferred genres by average rating
    pub fn top_genres(&self, n: usize) -> Vec<Genre> {
        let mut genres: Vec<_> = self.genre_preferences.iter().collect();
        genres.sort_by(|a, b| b.1.partial_cmp(a.1).unwrap());
        genres.into_iter().take(n).map(|(g, _)| *g).collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_candidate_creation() {
        let candidate = Candidate::new(1193, CandidateSource::Thunder, 0.85);
        assert_eq!(candidate.movie_id, 1193);
        assert_eq!(candidate.source, CandidateSource::Thunder);
        assert_eq!(candidate.base_score, 0.85);
    }

    #[test]
    fn test_user_context_top_genres() {
        let mut context = UserContext::new(1);
        context.genre_preferences.insert(Genre::Action, 4.5);
        context.genre_preferences.insert(Genre::Drama, 4.8);
        context.genre_preferences.insert(Genre::Comedy, 3.2);
        context.genre_preferences.insert(Genre::SciFi, 4.0);

        let top_3 = context.top_genres(3);
        assert_eq!(top_3.len(), 3);
        assert_eq!(top_3[0], Genre::Drama); // Highest rated
    }
}
